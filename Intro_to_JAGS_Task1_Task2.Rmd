---
title: "Intro_to_JAGs_Task1_Tasks2"
author: "Victor Feagins"
date: "6/7/2021"
output: html_document
---
## Packages

```{r}
library(rjags) #Uses JAGS to create bayesian models
library(coda)
library(tidyverse) #Utility functions
```

### Task 1
* Evaluate the MCMC chain for convergence. Include relevant diagnostics and plots. Determine and remove burn-in
* Report parameter summary table and plot marginal distributions
* Describe and explain the parameter covariances that you observe in the pairs plot and parameter correlation matrix.
* Compare the summary statistics for the Bayesian regression model to those from the classical regression:  summary(lm( y ~ x1 )).  This should include a comparison of the means and uncertainties of **all 3 model parameters**

#### Loading in Data
```{r}
load("data/Ex05.Part1.RData")

```

#### Modeling in Rjags
##### Model priors
```{r}
T.1.model <- "model {
#Model
for (i in 1:length(Y)) {
Y[i] ~ dnorm(mu[i], s^(-2))
mu[i] <- b0 + b1*x1[i]
}

#Prior
b0 ~ dnorm(0, 200^(-2))
b1 ~ dnorm(0, 200^(-2))

s ~ dunif(0,200)

}"
```


##### Model Data
```{r}
T.1.data <- list(
  Y = y,
  x1 = x1
)
```

##### Initalization 
```{r}
set.seed(10)
T.1.n.chains <- 3
T.1.inital.coef <- coef(T.1.lm <- lm(y ~ x1))
T.1.inits = list()
for(i in 1:T.1.n.chains){
  T.1.inits[[i]] <- list(b0 = rnorm(1,T.1.inital.coef['(Intercept)'],200),
                     b1 = rnorm(1,T.1.inital.coef["x1"], 200),
                     s = sigma(T.1.lm),
                     .RNG.name = "base::Wichmann-Hill",
                     .RNG.seed = 10)
}

```

##### Running Rjags

```{r}
T.1.n.adapt <- 1000
T.1.jags <- jags.model(
  file = textConnection(T.1.model),
  data = T.1.data,
  inits = T.1.inits,
  n.chains = T.1.n.chains,
  n.adapt = T.1.n.adapt
)
```

##### Simulating Priors

```{r}
T.1.n.iter <- 10000

T.1.sim <- coda.samples(
  model = T.1.jags,
  variable.names = c("b0", "b1", 's'),
  n.iter = T.1.n.iter
)
```

##### Diagnostics
First we examine the trace plots. We want to see convergence and overlap over the `r T.1.n.chains` chains

```{r}
plot(T.1.sim)
```

Let's see if the last 1000 iterations look like
```{r}
window(T.1.sim, T.1.n.iter) %>% 
  plot(., density = F)

```

I looks like the 3 chains are overlaping each other 

Next let's examine Brooks-Gelman-Rubin (BGR) statistic 

```{r}
gelman.diag(T.1.sim)

```

A value of 1 is great. If it was higher than 1.1 that would be bad.

Next let's get rid of samples that were before convergence. BGR statistic versus sample plots below. We want to remove samples that were when the BGR was greater then 1.05

```{r}
gelman.plot(T.1.sim)
```

Looking at the plots 1000 iterations seems to be a good burnin time. Keep in mind the plots are starting at 1000 because of the `n.adapt` from the `jags.model` 


##### Inference 

Before doing any inference it is important to remove burn in samples as they were before the convergence.

```{r}
T.1.burn <- 1000
T.1.sim.prior <- window(T.1.sim, T.1.n.adapt + T.1.burn) #observations after n.adapt
```

```{r}
acfplot(T.1.sim.prior) # how to make it not smushed
```

The autocorelation seems to decay after 10 lags.

```{r}
acf(T.1.sim.prior[[1]])
acf(T.1.sim.prior[[2]])
acf(T.1.sim.prior[[3]])
```

Yep in all the chains the acf dies down after 10 lags.

I want the effective Size to be greater then 5000. This is with `r T.1.n.iter` number of iterations
```{r}
effectiveSize(T.1.sim.prior)
```

